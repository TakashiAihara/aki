# AI プロンプト規約・ガイドライン

本ドキュメントは、モダン AI 開発手法における **AI への指示方針** を定義します。

---

## 目次

1. [全フェーズ共通ルール](#全フェーズ共通ルール)
2. [Phase 0: 思考・設計フェーズ](#phase-0-思考設計フェーズ)
3. [Phase 1: 実装フェーズ](#phase-1-実装フェーズ)
4. [Phase 2-3: レビューフェーズ](#phase-2-3-レビューフェーズ)
5. [ツール別プロンプト Tips](#ツール別プロンプト-tips)

---

## 全フェーズ共通ルール

### 1. 制約条件を最初に与える

AI に指示を出す際は、**必ず制約条件を先頭に明示** します。

#### YAGNI 原則の徹底

```markdown
❌ Bad:
「ユーザー管理機能を実装して」

✅ Good:
「ユーザー管理機能を実装して。
制約:
- YAGNI 原則に従う
- 将来拡張は考えない
- 最小構成で実装
- 余計なヘルパー関数・抽象化は追加しない」
```

#### 理由

制約を与えないと、AI は「良かれと思って」以下を追加します:

- 使わない抽象化レイヤ
- 過剰な設定項目
- 不要なデザインパターン
- 将来のための拡張ポイント

**これらは全て不要**。制約で防ぎます。

---

### 2. コンテキスト提供方法

#### ADR / Spec の参照

```markdown
❌ Bad:
「API を実装して」

✅ Good:
「ADR-0001 で決定した設計に従い、User API を実装して。
参照: docs/adr/0001-user-api-design.md」
```

#### ドメイン制約の伝え方

```markdown
✅ Good:
「本システムでは以下のドメイン制約があります:
- ユーザーは必ず1つの組織に所属
- 組織間のデータ共有は禁止
- 削除は論理削除のみ

この制約を守って実装してください」
```

---

### 3. 出力形式の指定

AI に何を返してほしいかを **明示的に指定** します。

#### コードの場合

```markdown
✅ Good:
「以下の仕様で User エンティティを実装してください。
出力形式:
- TypeScript
- クラスベース
- JSDoc コメント付き
- テストコードは不要」
```

#### 設計書の場合

```markdown
✅ Good:
「ユーザー管理機能の設計案を3つ提示してください。
出力形式:
- 各案の長所・短所を明記
- トレードオフを明示
- ADR 形式で出力」
```

---

## Phase 0: 思考・設計フェーズ

### 使用ツール

**Claude Code**（学習利用なし）

### プロンプト方針

Phase 0 では **業務ロジックの思想・制約** を明確化します。

#### 1. 業務ロジックの思想を固定

```markdown
✅ Good:
「ECサイトにおける注文処理の設計を考えたい。
業務ルール:
- 在庫引き当ては注文確定時（決済完了ではない）
- 在庫不足の場合は部分出荷を許可しない
- キャンセルは出荷前のみ可能

これらのルールを満たす設計案を2-3個提示し、
それぞれのトレードオフを ADR 形式で出力してください。」
```

#### 2. 複数案の提示を依頼

```markdown
✅ Good:
「認証機能の実装方針を決めたい。
検討すべき選択肢:
- JWT vs セッション
- Cookie vs LocalStorage
- トークン有効期限の設定

それぞれの長所・短所を比較し、推奨案を提示してください。」
```

#### 3. トレードオフの明示を求める

```markdown
✅ Good:
「データベースに PostgreSQL を採用するか、MySQL を採用するかを決めたい。
以下の観点で比較してください:
- JSON 型サポート
- レプリケーション
- 運用コスト
- チームの習熟度

トレードオフを明示した上で、推奨案を提示してください。」
```

#### 4. ADR 形式での出力を指定

```markdown
✅ Good:
「上記の検討結果を ADR 形式で出力してください。
テンプレート: docs/adr/template.md」
```

---

### Phase 0 でやってはいけないこと

❌ **いきなり実装を依頼**

```markdown
❌ Bad:
「ユーザー管理機能を作って」
```

これは Phase 1 の仕事です。Phase 0 では **設計のみ** を行います。

---

## Phase 1: 実装フェーズ

### 使用ツール

- **SiliconFlow**（メイン、日本語強い）
- **Cerebras**（大量処理・高速）
- **OpenRouter**（フェイルオーバー）

### プロンプト方針

Phase 1 では **Phase 0 で固定した設計に従って実装** します。

#### 1. Phase 0 で固定した設計を参照させる

```markdown
✅ Good:
「ADR-0001 で決定した設計に従い、User CRUD API を実装してください。
参照: docs/adr/0001-user-api-design.md

仕様:
- GET /users/:id - ユーザー取得
- POST /users - ユーザー作成
- PUT /users/:id - ユーザー更新
- DELETE /users/:id - ユーザー削除（論理削除）

制約:
- 余計な抽象化は追加しない
- エラーハンドリングはコントローラー層のみ
- バリデーションは既存の Validator クラスを使用」
```

#### 2. Boilerplate / CRUD のみを依頼

```markdown
✅ Good:
「以下の Entity に対する CRUD Repository を実装してください。
Entity: User (id, name, email, createdAt, updatedAt)

生成するもの:
- UserRepository クラス
- 基本的な CRUD メソッド（create, findById, update, delete）

生成しないもの:
- 複雑なクエリ（必要になったら後で追加）
- キャッシュ層（YAGNI）
- トランザクション管理（別レイヤで対応）」
```

#### 3. 業務ロジックの思想は含めない

```markdown
❌ Bad:
「注文処理の実装をお願い。在庫管理とか決済とか良い感じに」

✅ Good:
「ADR-0002 で定義した注文処理ロジックを実装してください。
参照: docs/adr/0002-order-processing-logic.md

実装する処理:
1. 在庫引き当て（Phase 0 で定義済み）
2. 注文レコード作成
3. イベント発行

ビジネスルールは ADR に記載済みなので、そのまま実装してください。」
```

---

### Phase 1 でやってはいけないこと

❌ **設計を AI に丸投げ**

```markdown
❌ Bad:
「ユーザー管理の API を良い感じに実装して」
```

Phase 0 で設計は固定済みです。Phase 1 では実装のみを依頼します。

---

## Phase 2-3: レビューフェーズ

### Phase 2: AI レビュー（自動）

**使用ツール**: CodeRabbit / SonarQube

#### CodeRabbit の設定

`.coderabbit.yaml` で以下をチェック:

```yaml
reviews:
  auto_review:
    enabled: true
  checks:
    - naming_conventions
    - complexity
    - duplication
    - n_plus_one_queries
    - security_vulnerabilities
```

#### SonarQube の設定

- 技術的負債の検出
- コード複雑度のチェック
- セキュリティホールの検出

---

### Phase 3: 人間レビュー（最小）

人間は **設計意図との乖離** のみを確認します。

#### レビュー観点

- [ ] Phase 0 の ADR に従っているか？
- [ ] 過剰な抽象化が追加されていないか？
- [ ] YAGNI 原則が守られているか？
- [ ] 将来のための「余計な拡張ポイント」が追加されていないか？

---

## ツール別プロンプト Tips

### Claude Code（Phase 0）

#### 得意分野

- 設計・アーキテクチャ検討
- トレードオフ分析
- ADR 作成

#### 効果的なプロンプト

```markdown
✅ Good:
「なぜこの設計を選んだのか、理由を説明してください。
また、選ばなかった代替案との比較も示してください。」
```

Claude は「なぜ?」に答えるのが得意です。

---

### SiliconFlow（Phase 1）

#### 得意分野

- 日本語コーディング
- Qwen 2.5 Coder ベース

#### 効果的なプロンプト

```markdown
✅ Good:
「以下のサンプルコードと同じスタイルで User API を実装してください。
[サンプルコードを添付]

変更点:
- Entity を User に変更
- フィールドを追加: age, address」
```

具体的なコード例を添付すると、スタイルを踏襲してくれます。

---

### Cerebras（Phase 1）

#### 得意分野

- 大量処理
- 超高速推論（1,800 tok/s）

#### 効果的なプロンプト

```markdown
✅ Good:
「以下の100個のエンティティに対して CRUD Repository を一括生成してください。
[エンティティリスト]

各エンティティに対して同じパターンで生成してください。」
```

大量のコード生成はCerebrasが最速です。

---

### OpenRouter（Phase 1 - Reasoning）

#### 得意分野

- DeepSeek R1 による推論
- 複雑なロジックの実装

#### 効果的なプロンプト

```markdown
✅ Good:
「以下のビジネスルールを満たすアルゴリズムを実装してください。
[複雑なルール]

段階的に推論しながら実装を進めてください。」
```

DeepSeek R1 は推論プロセスを表示しながら実装します。

---

## プロンプトテンプレート

### Phase 0: 設計検討

```markdown
【タスク】
[何を設計するか]

【背景・制約】
[ビジネスルール、技術的制約]

【検討すべき選択肢】
- Option 1: [案1]
- Option 2: [案2]
- Option 3: [案3]

【出力形式】
- 各選択肢の長所・短所を明記
- トレードオフを明示
- 推奨案を提示
- ADR 形式で出力
```

---

### Phase 1: 実装

```markdown
【タスク】
ADR-NNNN で決定した [機能名] を実装

【参照】
docs/adr/NNNN-xxx.md

【仕様】
[具体的な仕様]

【制約】
- YAGNI 原則
- 最小構成
- 余計な抽象化は追加しない

【出力】
[言語、形式、テストの有無]
```

---

## まとめ

| Phase    | ツール                     | プロンプトの要点                   |
| -------- | ----------------------- | -------------------------- |
| Phase 0  | Claude Code             | 「なぜ?」を問う、ADR形式で出力          |
| Phase 1  | SiliconFlow / Cerebras  | ADR参照、制約明示、サンプルコード添付       |
| Phase 2  | CodeRabbit / SonarQube  | 設定ファイルでチェック項目を定義           |
| Phase 3  | 人間                      | 設計意図との乖離のみをチェック            |

---

*最終更新: 2025年1月*
