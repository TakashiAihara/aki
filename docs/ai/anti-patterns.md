# AI プロンプト アンチパターン集

**やってはいけないプロンプト例**と、その改善方法を示します。

---

## 目次

1. [制約なしの丸投げ](#1-制約なしの丸投げ)
2. [Phase スキップ](#2-phase-スキップ)
3. [過剰設計を誘発する指示](#3-過剰設計を誘発する指示)
4. [学習利用 AI に業務ロジックを渡す](#4-学習利用-ai-に業務ロジックを渡す)
5. [曖昧な要求](#5-曖昧な要求)
6. [出力形式の未指定](#6-出力形式の未指定)

---

## 1. 制約なしの丸投げ

### ❌ Bad

```markdown
「ユーザー管理機能を作って」
```

### 問題点

- AI が「良かれと思って」過剰設計する
- 将来拡張のための抽象化レイヤを追加
- 使わない機能まで実装される

### ✅ Good

```markdown
「ユーザー管理機能を実装してください。

制約:
- YAGNI 原則を厳守
- 将来拡張は考えない
- 最小構成で実装
- 余計な抽象化は追加しない

実装する機能:
- ユーザー作成
- ユーザー取得
- ユーザー更新
- ユーザー削除（論理削除）

実装しない機能:
- パスワードリセット（今回不要）
- メール認証（今回不要）
- ソーシャルログイン（今回不要）」
```

### 学び

**制約を明示しないと、AI は親切心で余計なことをします。**

---

## 2. Phase スキップ

### ❌ Bad

```markdown
「ECサイトの注文機能を実装して」
```

### 問題点

- Phase 0（設計）をスキップしていきなり実装
- 業務ロジックの思想が固定されていない
- AI が勝手に設計を決めてしまう

### ✅ Good

**Step 1: Phase 0（Claude Code で設計）**

```markdown
「ECサイトの注文機能の設計を考えたい。

業務ルール:
- 在庫引き当ては注文確定時
- 在庫不足の場合は部分出荷を許可しない
- キャンセルは出荷前のみ可能

これらのルールを満たす設計案を2-3個提示し、
ADR 形式で出力してください。」
```

**Step 2: Phase 1（SiliconFlow で実装）**

```markdown
「ADR-0010 で決定した注文処理ロジックを実装してください。
参照: docs/adr/0010-order-processing-logic.md」
```

### 学び

**Phase 0 で設計を固定してから Phase 1 で実装する。**

---

## 3. 過剰設計を誘発する指示

### ❌ Bad: 「将来のために拡張可能に」

```markdown
「ユーザー管理 API を実装して。
将来的に他の認証方式にも対応できるよう、拡張可能にしてください。」
```

### 問題点

- 今は使わない抽象化レイヤが追加される
- インターフェース、Factory パターン、Strategy パターンなどが乱用される
- コードが複雑になり、メンテナンスコストが上がる

### ✅ Good

```markdown
「ユーザー管理 API を実装してください。

制約:
- 認証方式はメール+パスワードのみ
- 将来の拡張は考えない（YAGNI）
- インターフェースや抽象化は不要
- 直接実装でOK」
```

---

### ❌ Bad: 「スケーラブルに」

```markdown
「ブログシステムを実装して。
将来的にユーザーが100万人になっても大丈夫なように、
スケーラブルな設計にしてください。」
```

### 問題点

- 今は不要なキャッシュ層、キューイングシステムが追加される
- マイクロサービス化が提案される
- 過剰なインフラ設計

### ✅ Good

```markdown
「ブログシステムを実装してください。

想定ユーザー数: 100人
想定記事数: 1,000件

制約:
- 現時点の規模に最適化
- スケーラビリティは考えない
- キャッシュ層は不要
- シンプルなモノリス構成」
```

---

### ❌ Bad: 「保守性を高めて」

```markdown
「商品管理機能を実装して。
将来的に仕様変更があっても対応できるよう、
保守性を高めてください。」
```

### 問題点

- 抽象化レイヤが過剰に追加される
- Repository パターン、Service パターン、DTO など全て追加される
- コードが複雑化

### ✅ Good

```markdown
「商品管理機能を実装してください。

制約:
- シンプルな3層アーキテクチャ（Controller / Service / Repository）
- 過剰な抽象化は不要
- 保守性は「読みやすさ」で確保する」
```

---

### 学び

**「将来のため」「拡張可能に」「スケーラブルに」は禁句。**

---

## 4. 学習利用 AI に業務ロジックを渡す

### ❌ Bad

```markdown
「当社の特殊な在庫管理ロジックを実装して。

ルール:
- 在庫は3種類（通常在庫、予約在庫、返品在庫）に分類
- 予約在庫は72時間でタイムアウト
- 返品在庫は検品後に通常在庫に戻す
- 在庫引き当ては優先度: 通常 > 返品 > 予約

この独自ルールを実装してください。」

[SiliconFlow に投げる] ← ❌ 学習利用される！
```

### 問題点

- 業務ロジックの **思想・独自ルール** が学習データに含まれる
- 競合他社が同じ AI を使う場合、類似の実装を提案される可能性

### ✅ Good

**Phase 0（Claude Code）で設計を固定**

```markdown
「在庫管理の設計を考えたい。

要件:
- 在庫を3種類に分類
- タイムアウト処理
- 優先度付き引き当て

設計案を提示し、ADR 形式で出力してください。」
```

**Phase 1（SiliconFlow）では抽象化後のコードのみ**

```markdown
「ADR-0020 で定義した在庫管理ロジックを実装してください。
参照: docs/adr/0020-inventory-management.md

実装する処理:
- allocate(type, quantity): 在庫引き当て
- release(type, quantity): 在庫解放

ビジネスルールは ADR に記載済み。」
```

### 学び

**Phase 0 で業務思想を固定し、Phase 1 では Boilerplate のみ生成。**

---

## 5. 曖昧な要求

### ❌ Bad: 「良い感じに」

```markdown
「ユーザー認証を良い感じに実装して」
```

### 問題点

- AI が勝手に認証方式を決める（JWT / Session / OAuth 何でもあり）
- セキュリティ要件が不明確
- 期待と違う実装になる

### ✅ Good

```markdown
「ユーザー認証を実装してください。

認証方式: JWT
トークン保存: HTTP-only Cookie
有効期限: 7日間
リフレッシュトークン: あり（30日間）

セキュリティ要件:
- HTTPS必須
- CSRF対策: SameSite=Strict
- XSS対策: HTTP-only Cookie」
```

---

### ❌ Bad: 「適切に」

```markdown
「エラーハンドリングを適切に実装して」
```

### 問題点

- 「適切」の定義が不明
- AI が過剰なエラーハンドリングを追加する可能性

### ✅ Good

```markdown
「エラーハンドリングを実装してください。

方針:
- 例外は上位レイヤでキャッチ
- エラーレスポンスは { "error": "message" } 形式
- ログは既存の Logger クラスを使用
- リトライ処理は不要（YAGNI）」
```

---

### 学び

**「良い感じに」「適切に」は使わない。具体的に指定する。**

---

## 6. 出力形式の未指定

### ❌ Bad

```markdown
「User エンティティを実装して」
```

### 問題点

- クラスなのか、インターフェースなのか不明
- ファイル構成が不明
- コメントの有無が不明

### ✅ Good

```markdown
「User エンティティを実装してください。

出力形式:
- 言語: TypeScript
- 形式: クラス
- フィールド: private、getter/setterあり
- コメント: JSDoc形式
- ファイルパス: src/entities/User.ts」
```

---

### ❌ Bad

```markdown
「API のテストを書いて」
```

### 問題点

- テストフレームワークが不明
- テストケースの粒度が不明

### ✅ Good

```markdown
「User API のテストを実装してください。

出力形式:
- テストフレームワーク: Jest
- ファイルパス: src/api/__tests__/UserAPI.test.ts
- カバレッジ目標: 80%
- モック: API Client をモック

テストケース:
- 正常系: ユーザー作成成功
- 異常系: メール重複エラー
- 異常系: バリデーションエラー」
```

---

### 学び

**出力形式を明示しないと、期待と違うコードが返ってくる。**

---

## まとめ: やってはいけないプロンプト

| アンチパターン      | 理由                    | 改善方法              |
| ------------ | --------------------- | ----------------- |
| 制約なしの丸投げ     | AI が過剰設計する            | 制約を明示             |
| Phase スキップ   | 設計が固定されていない           | Phase 0 → Phase 1 |
| 「将来のために」    | 不要な抽象化が追加される          | YAGNI を明示         |
| 業務ロジックを学習AI | 独自ルールが学習される           | Phase 0 で分離       |
| 「良い感じに」     | 曖昧で期待と違う実装になる         | 具体的に指定            |
| 出力形式未指定      | 期待と違うコードが返ってくる        | 出力形式を明示           |

---

## チェックリスト

プロンプトを書く前に確認:

- [ ] 制約条件（YAGNI）を明示したか？
- [ ] Phase 0 で設計を固定したか？
- [ ] 「将来のため」「拡張可能に」と書いていないか？
- [ ] ADR / Spec への参照を含めたか？
- [ ] 出力形式を具体的に指定したか？
- [ ] 業務ロジックの思想を学習AIに渡していないか？

---

*最終更新: 2025年1月*
